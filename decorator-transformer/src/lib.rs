use serde::{Deserialize, Serialize};
use oxc_allocator::Allocator;
use oxc_codegen::Codegen;
use oxc_parser::Parser;
use oxc_span::SourceType;

mod transformer;
use transformer::{DecoratorTransformer, TransformerState};

// Note: WIT bindgen configuration requires cargo-component build tool
// The actual WASM Component generation happens during build with:
// cargo component build --release
//
// This stub allows the Rust code to compile and be tested
// The actual Component Model exports are generated by cargo-component

#[derive(Serialize, Deserialize, Debug)]
pub struct TransformOptions {
    #[serde(default = "default_true")]
    pub source_maps: bool,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct TransformResult {
    pub code: String,
    pub map: Option<String>,
    pub errors: Vec<String>,
}

fn default_true() -> bool {
    true
}

/// Transform JavaScript/TypeScript code with decorators
/// 
/// This function implements the core transformation logic.
/// It is called by the WASM Component Model export when built with cargo-component.
pub fn transform(
    filename: String,
    source_text: String,
    options: String,
) -> Result<TransformResult, String> {
    // Parse options from JSON string
    let opts: TransformOptions = if options.is_empty() {
        TransformOptions { source_maps: true }
    } else {
        serde_json::from_str(&options)
            .map_err(|e| format!("Invalid options: {}", e))?
    };

    // Create allocator for AST
    let allocator = Allocator::default();
    
    // Determine source type from filename
    let source_type = SourceType::from_path(&filename).unwrap_or_default();
    
    // Parse the source code
    let parser = Parser::new(&allocator, &source_text, source_type);
    let mut parse_result = parser.parse();
    
    // Check for parse errors
    if !parse_result.errors.is_empty() {
        let errors: Vec<String> = parse_result
            .errors
            .iter()
            .map(|e| format!("{:?}", e))
            .collect();
        
        return Ok(TransformResult {
            code: source_text.clone(),
            map: None,
            errors,
        });
    }

    // Apply decorator transformation
    let mut transformer = DecoratorTransformer::new(&allocator);
    let mut state = TransformerState;
    transformer.traverse_program(&mut parse_result.program, &mut state);
    
    // Generate code from transformed AST
    let codegen_result = Codegen::new().build(&parse_result.program);
    
    Ok(TransformResult {
        code: codegen_result.code,
        map: if opts.source_maps {
            codegen_result.map.map(|m| m.to_json_string())
        } else {
            None
        },
        errors: transformer.errors,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_parsing() {
        let code = "const x = 1;";
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        assert!(result.is_ok());
    }

    #[test]
    fn test_class_decorator_detected() {
        let code = r#"
            function dec(target) { return target; }
            @dec
            class C {}
        "#;
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        assert!(result.is_ok());
        if let Ok(res) = result {
            assert!(res.code.contains("class C"));
            // Should have detected decorators
            assert!(res.errors.len() > 0 || res.code.contains("class C"));
        }
    }

    #[test]
    fn test_method_decorator_detected() {
        let code = "class C { @dec method() {} }";
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        assert!(result.is_ok());
    }

    #[test]
    fn test_options_parsing() {
        let code = "const x = 1;";
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            r#"{"source_maps": false}"#.to_string(),
        );
        assert!(result.is_ok());
        if let Ok(res) = result {
            assert!(res.map.is_none());
        }
    }
}
