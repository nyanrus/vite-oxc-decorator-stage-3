use serde::{Deserialize, Serialize};
use oxc_allocator::Allocator;
use oxc_codegen::Codegen;
use oxc_parser::Parser;
use oxc_span::SourceType;
use oxc_traverse::traverse_mut;
use oxc_semantic::SemanticBuilder;

mod transformer;
mod codegen;
use transformer::{DecoratorTransformer, TransformerState};
use codegen::generate_helper_functions;

// Note: WIT bindgen configuration requires cargo-component build tool
// The actual WASM Component generation happens during build with:
// cargo component build --release
//
// This stub allows the Rust code to compile and be tested
// The actual Component Model exports are generated by cargo-component

#[derive(Serialize, Deserialize, Debug)]
pub struct TransformOptions {
    #[serde(default = "default_true")]
    pub source_maps: bool,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct TransformResult {
    pub code: String,
    pub map: Option<String>,
    pub errors: Vec<String>,
}

fn default_true() -> bool {
    true
}

/// Transform JavaScript/TypeScript code with decorators
/// 
/// This function implements the core transformation logic for TC39 Stage 3 decorators.
/// It parses the code, detects decorators, injects helper functions, and generates
/// the proper transformation.
pub fn transform(
    filename: String,
    source_text: String,
    options: String,
) -> Result<TransformResult, String> {
    // Parse options from JSON string
    let opts: TransformOptions = if options.is_empty() {
        TransformOptions { source_maps: true }
    } else {
        serde_json::from_str(&options)
            .map_err(|e| format!("Invalid options: {}", e))?
    };

    // Create allocator for AST
    let allocator = Allocator::default();
    
    // Determine source type from filename
    let source_type = SourceType::from_path(&filename).unwrap_or_default();
    
    // Parse the source code
    let parser = Parser::new(&allocator, &source_text, source_type);
    let mut parse_result = parser.parse();
    
    // Check for parse errors
    if !parse_result.errors.is_empty() {
        let errors: Vec<String> = parse_result
            .errors
            .iter()
            .map(|e| format!("{:?}", e))
            .collect();
        
        return Ok(TransformResult {
            code: source_text.clone(),
            map: None,
            errors,
        });
    }

    // Check if code has decorators before transforming
    let mut transformer = DecoratorTransformer::new(&allocator);
    let has_decorators = transformer.check_for_decorators(&parse_result.program);
    
    if !has_decorators {
        // No decorators, return original code
        let codegen_result = Codegen::new().build(&parse_result.program);
        return Ok(TransformResult {
            code: codegen_result.code,
            map: if opts.source_maps {
                codegen_result.map.map(|m| m.to_json_string())
            } else {
                None
            },
            errors: vec![],
        });
    }

    // Apply decorator transformation
    // Build semantic information (scoping) required by traverse_mut
    let semantic_ret = SemanticBuilder::new()
        .build(&parse_result.program);
    let scoping = semantic_ret.semantic.into_scoping();
    
    let state = TransformerState;
    traverse_mut(&mut transformer, &allocator, &mut parse_result.program, scoping, state);
    
    // Generate code from transformed AST
    let mut codegen_result = Codegen::new().build(&parse_result.program);
    
    // Inject helper functions at the beginning of the code
    if transformer.needs_helpers() {
        let helpers = generate_helper_functions();
        codegen_result.code = format!("{}\n{}", helpers, codegen_result.code);
    }
    
    Ok(TransformResult {
        code: codegen_result.code,
        map: if opts.source_maps {
            codegen_result.map.map(|m| m.to_json_string())
        } else {
            None
        },
        errors: transformer.errors,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_parsing() {
        let code = "const x = 1;";
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        assert!(result.is_ok());
    }

    #[test]
    fn test_class_decorator_detected() {
        let code = r#"
            function dec(target) { return target; }
            @dec
            class C {}
        "#;
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        assert!(result.is_ok());
        if let Ok(res) = result {
            assert!(res.code.contains("class C"));
            // Decorators should be removed (no errors)
            assert_eq!(res.errors.len(), 0);
            // The decorator syntax should be removed from output
            assert!(!res.code.contains("@dec"));
        }
    }
    
    #[test]
    fn test_decorator_removal() {
        let code = r#"
            @classDecorator
            class MyClass {
                @methodDecorator
                method() {}
                
                @fieldDecorator
                field = 1;
            }
        "#;
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        assert!(result.is_ok());
        if let Ok(res) = result {
            // All decorators should be stripped
            assert!(!res.code.contains("@classDecorator"));
            assert!(!res.code.contains("@methodDecorator"));
            assert!(!res.code.contains("@fieldDecorator"));
            // But the class structure should remain
            assert!(res.code.contains("class MyClass"));
            assert!(res.code.contains("method()"));
            assert!(res.code.contains("field = 1"));
            assert_eq!(res.errors.len(), 0);
        }
    }
    
    #[test]
    fn test_complex_decorator_scenario() {
        let code = r#"
            function logged(value, context) {
                console.log(`Decorating ${context.name}`);
                return value;
            }
            
            function bound(value, context) {
                return value;
            }
            
            @logged
            class Controller {
                @logged
                static staticMethod() {
                    return 'static';
                }
                
                @bound
                @logged
                instanceMethod() {
                    return 'instance';
                }
                
                @logged
                get value() {
                    return this._value;
                }
                
                @logged
                set value(v) {
                    this._value = v;
                }
                
                @logged
                accessor data = 42;
                
                @logged
                #privateMethod() {
                    return 'private';
                }
            }
        "#;
        
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        
        assert!(result.is_ok());
        if let Ok(res) = result {
            // All decorators should be removed
            assert!(!res.code.contains("@logged"));
            assert!(!res.code.contains("@bound"));
            
            // Class structure should be preserved
            assert!(res.code.contains("class Controller"));
            assert!(res.code.contains("static staticMethod()"));
            assert!(res.code.contains("instanceMethod()"));
            assert!(res.code.contains("get value()"));
            assert!(res.code.contains("set value("));
            assert!(res.code.contains("accessor data"));
            assert!(res.code.contains("#privateMethod()"));
            
            // Helper functions should remain
            assert!(res.code.contains("function logged"));
            assert!(res.code.contains("function bound"));
            
            // No errors
            assert_eq!(res.errors.len(), 0);
        }
    }

    #[test]
    fn test_helper_injection_on_decorator_presence() {
        let code = r#"
            function logged(value, { kind, name }) {
                if (kind === "method") {
                    return function (...args) {
                        console.log(`calling ${name}`);
                        return value.call(this, ...args);
                    };
                }
            }

            class C {
                @logged
                m(arg) {
                    return arg * 2;
                }
            }
        "#;
        
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        
        assert!(result.is_ok());
        if let Ok(res) = result {
            // Helper functions should be injected
            assert!(res.code.contains("function _applyDecs"));
            assert!(res.code.contains("function _toPropertyKey"));
            assert!(res.code.contains("function _toPrimitive"));
            assert!(res.code.contains("function _setFunctionName"));
            assert!(res.code.contains("function _checkInRHS"));
            
            // Original code should still be present (without @decorator syntax)
            assert!(res.code.contains("class C"));
            assert!(res.code.contains("function logged"));
            assert!(!res.code.contains("@logged")); // Decorator syntax removed
            
            // No errors
            assert_eq!(res.errors.len(), 0);
        }
    }

    #[test]
    fn test_no_helper_injection_without_decorators() {
        let code = r#"
            class C {
                m(arg) {
                    return arg * 2;
                }
            }
        "#;
        
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        
        assert!(result.is_ok());
        if let Ok(res) = result {
            // Helper functions should NOT be injected when no decorators
            assert!(!res.code.contains("function _applyDecs"));
            assert!(!res.code.contains("function _toPropertyKey"));
            
            // Original code should be present
            assert!(res.code.contains("class C"));
            
            // No errors
            assert_eq!(res.errors.len(), 0);
        }
    }

    #[test]
    fn test_method_decorator_detected() {
        let code = "class C { @dec method() {} }";
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            "{}".to_string(),
        );
        assert!(result.is_ok());
    }

    #[test]
    fn test_options_parsing() {
        let code = "const x = 1;";
        let result = transform(
            "test.js".to_string(),
            code.to_string(),
            r#"{"source_maps": false}"#.to_string(),
        );
        assert!(result.is_ok());
        if let Ok(res) = result {
            assert!(res.map.is_none());
        }
    }
}
